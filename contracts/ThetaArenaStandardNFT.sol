// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

contract ThetaArenaStandardNFT is
	ERC721,
	AccessControlEnumerable,
	ERC721Enumerable,
	Ownable
{
	mapping(address => bool) public allowedProxies;
	string private _baseTokenURI;
	bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

	constructor(
		string memory name,
		string memory symbol,
		string memory baseTokenURI
	) ERC721(name, symbol) {
		_baseTokenURI = baseTokenURI;
		_setupRole(MINTER_ROLE, _msgSender());
	}

	/**
	 * @dev Creates a new token for `to`. Its token ID will be automatically
	 * assigned (and available on the emitted {IERC721-Transfer} event), and the token
	 * URI autogenerated based on the base URI passed at construction.
	 *
	 * See {ERC721-_mint}.
	 *
	 * Requirements:
	 *
	 * - the caller must have the `MINTER_ROLE`.
	 */
	function mint(address to, uint256 tokenId) public virtual {
		require(
			hasRole(MINTER_ROLE, _msgSender()),
			"ThetaArenaStandardNFT: must have minter role to mint"
		);
		require(
			!_exists(tokenId),
			"ThetaArenaStandardNFT: must have unique tokenId"
		);
		// We cannot just use balanceOf to create the new tokenId because tokens
		// can be burned (destroyed), so we need a separate counter.
		_mint(to, tokenId);
	}

	/**
	 * @dev See {IERC721-isApprovedForAll}.
	 */
	function isApprovedForAll(address owner, address operator)
		public
		view
		override
		returns (bool)
	{
		if (allowedProxies[operator] == true) {
			return true;
		}

		return super.isApprovedForAll(owner, operator);
	}

	/**
	 * @dev Allow proxy to reduce gas fee.
	 */
	function allowProxy(address proxy) public onlyOwner {
		require(
			allowedProxies[proxy] == false,
			"ThetaArenaStandardNFT: invalid proxy address"
		);

		allowedProxies[proxy] = true;
	}

	/**
	 * @dev Remove proxy from allowed list.
	 */
	function removeProxy(address proxy) public onlyOwner {
		allowedProxies[proxy] = false;
	}

	/**
	 * @dev See {IERC165-_beforeTokenTransfer}.
	 */
	function _beforeTokenTransfer(
		address from,
		address to,
		uint256 tokenId
	) internal virtual override(ERC721, ERC721Enumerable) {
		super._beforeTokenTransfer(from, to, tokenId);
	}

	/**
	 * @dev See {IERC165-supportsInterface}.
	 */
	function supportsInterface(bytes4 interfaceId)
		public
		view
		virtual
		override(AccessControlEnumerable, ERC721, ERC721Enumerable)
		returns (bool)
	{
		return super.supportsInterface(interfaceId);
	}
}
